
#### 식별자의 역할은?
---
정규화 수행의 결정자 역할

종속자 도출하는 결정자 역할

#### 식별자의 도출은 언제?
---
###### 개념 모델링 단계

중요 엔티티/관계 도출하는 단계이므로 

속성까지는 생략해도 되나 업무 식별자 도출은 권고

###### 물리 모델링 단계

주 식별자 도출해야 함

#### 예제
---

>**Note**
> (α) 학교 데이터베이스 커스텀 예제로 책과 다름.

**도서 관리 테이블**

| 도서번호 | 도서명 | 저자 | 출판사 | 출판일 | ISBN | 카테고리 | 재고 수량 |
| -------- | ------ | ---- | ------ | ------ | ---- | -------- | -------- |
| 10001    | 해리 포터와 마법사의 돌 | J.K. 롤링 | 문학수첩 | 2000-07-26 | 978-3-16-148410-0 | 판타지 | 30 |
| 10002    | 해리 포터와 비밀의 방 | J.K. 롤링 | 문학수첩 | 2001-07-02 | 978-3-16-148411-7 | 판타지 | 25 |
| 10003    | 지적 대화를 위한 넓고 얕은 지식 | 채사장 | 웨일북 | 2014-12-17 | 978-3-16-148412-4 | 비평 | 20 |


### 1. 후보 식별자 (Candidate Identifier)
---

후보 식별자는 인스턴스의 유일성을 보장하며 최소 속성으로 구성 된 키. 

하나의 엔티티에 여러 개의 후보 식별자가 있을 수 있으며, 엔티티 내에서 함수 종속성을 발생시키는 결정자 역할을 함. 

후보 식별자를 알면 나머지 속성 값들도 알 수 있으며, 엔티티 정의/정규화의 기준이 됨.

엔티티 정의/정규화 하는 기준이 됨.

정규화 수행 시 다른 후보 식별자가 다른 릴레이션으로 분리될 수도 있음.

유일성을 보장 하긴 하지만 널을 허용할 수 있음.

유니크 인덱스 생성해 주어야 함.

>**Note**
> 위 예제의 함수 종속을 살펴보면. \
> FD1 : 도서번호 -> 도서명, 저자, 출판사, 출판일, ISBN, 카테고리, 재고 수량 \
> FD2 : ISBN -> 도서명, 저자, 출판사, 출판일, 카테고리 \
> 위와 같으며 결정자가 후보 식별자가 되므로 <font color="#00ffcc">도서번호</font> 와 <font color="#00ffcc">ISBN</font> 이 후보 식별자임.

### 2. 주 식별자 (Primary Identifier)
---

후보 식별자 중 성능/관리 측면에서 가장 좋은 식별자를 주 식별자로 선정

후보 식별자 중 주 식별자가 될 만 한 적당한 식별자가 없으면 인조 식별자 생성

엔티티에서 하나만 존재 할 수 있으며 반드시 하나는 존재해야 함.

PK(Primary Key) 라고 한다

>**Note**
>예제에서는 도서번호 를 주 식별자로 선택. \
>이 속성이 테이블에서 각 도서를 유일하게 구분하는 키 역할을 함.

### 3. 대리 식별자 (Alternate Identifier)
---

후보 식별자가 여러 개일 때 후보 식별자 중에서 주 식별자로 선택되고 남은 나머지 후보 식별자를 대리 식별자라고 함.

AK(Alternate Key) 라고 함.

>**Note**
>후보 식별자 중주 식별자가 아닌 남은 한가지 ISBN 을 대리 식별자로 선정하였음. \
>이 속성도 도서를 유일하게 구분할 수 있지만 주 식별자로 선택되지 않았음.

### 4. 인조 식별자 (Artificial Identifier)
---

위 예제에서는 도서번호 가 인조 식별자 역할을 하며, 도서 관리를 위한 무의미한 번호로 사용됨.

**인조 식별자 사용 조건**

1. **후보 식별자 중 주 식별자로 적합한 것이 없을 때**: 후보 식별자가 없거나 후보 식별자가 불안정하거나 변할 수 있는 경우에 인조 식별자를 사용.
2. **후보 식별자 속성 조합이 복잡할 때**: 후보 식별자가 여러 속성으로 이루어져 있어 복잡한 경우, 간단한 인조 식별자를 도입하여 관리를 용이하게 함.
3. **실체/자립 엔티티에서 사용**: 실체/자립 엔티티는 다른 엔터티들과의 관계에 의존하지 않으므로, 인조 식별자를 사용하여 독립적으로 식별이 가능하도록 함.

**인조 식별자 명명 규칙**

인조 식별자는 주로 "코드", "번호" 등의 단어를 사용하여 명명함.

하지만 "코드"라는 단어는 공통코드 속성과 혼동될 수 있으므로, 권장하지 않음.

**인조 식별자 도입 단계**

1. **주요 엔티티**: 개념모델 단계에서 인조 식별자를 고려함. \
    주요 엔티티는 전체 시스템에서 중심 역할을 하므로, 초기 단계에서 식별자를 결정하는 것이 중요.
2. **일반 엔티티**: 논리모델 단계에서 인조 식별자를 고려함. \
    일반 엔티티의 경우 데이터 모델이 확정된 후에 인조 식별자를 도입하는 것이 적합함.

인조 식별자 장단점.

|**장점**|**단점**|
|---|---|
|모델이 간소화된다.|인스턴스 생성 기준을 판단하기 어렵다.|
|SQL이 간소화된다.|실제 업무 식별자에 추가 키 관리가 필요하다.|
|후보 식별자가 없거나 복잡할 때 유용하다.|모델만 보고 업무를 이해하기 어렵다.|
|특정 엔터티를 빠르게 고유하게 식별한다.|행위 엔티티에서 가독성이 저하된다.|

>**Note**
> (α) 인조 식별자 추가 예제 3가지.

**예제 1: 참가자 관리**

다양한 국적과 이름을 가진 참가자들이 참여하는 국제 행사에서, 
참가자의 이름과 국적이 중복될 수 있기 때문에 이름과 국적만으로 참가자를 구별하는 것이 어려움.

| ParticipantID | Name        | Nationality | DateOfBirth | Gender |
| ------------- | ----------- | ----------- | ----------- | ------ |
| P001          | John Smith  | USA         | 1990-01-15  | Male   |
| P002          | John Smith  | UK          | 1985-11-20  | Male   |
| P003          | John Smith  | USA         | 1990-01-15  | Male   |
| P004          | Maria Kim   | South Korea | 1992-05-30  | Female |

`ParticipantID`는 인조 식별자로 참가자를 고유하게 식별.

**예제 2: 자동차 관리**

자동차를 관리하는 시스템에서, 차량 번호와 모델만으로는 차량 번호와 모델이 중복될 수 있기 때문에 차량을 구별하는 것이 어려움.

| VehicleID | LicensePlate | Model   | Color  | Year |
| --------- | ------------ | ------- | ------ | ---- |
| V001      | ABC123       | Accord  | Black  | 2018 |
| V002      | DEF456       | Camry   | White  | 2017 |
| V003      | ABC123       | Accord  | Black  | 2019 |
| V004      | GHI789       | Civic   | Silver | 2020 |

`VehicleID`는 인조 식별자로 차량을 고유하게 식별.

**예제 3: 상품 관리**

상품을 관리하는 시스템에서, 상품명과 카테고리만으로는 상품명과 카테고리가 중복될 수 있기 때문에 상품을 구별하는 것이 어려움.

| ProductID | ProductName | Category | Price | Stock |
| --------- | ----------- | -------- | ----- | ----- |
| P001      | Apple       | Fruit    | 0.5   | 100   |
| P002      | Orange      | Fruit    | 0.6   | 50    |
| P003      | Apple       | Fruit    | 0.5   | 200   |
| P004      | Carrot      | Vegetable| 0.3   | 150   |

`ProductID`는 인조 식별자로 상품을 고유하게 식별.

### 5. 외래 식별자 (Foreign Identifier)
---

상위 엔티티의 주 식별자가 하위 엔티티의 외래 식별자가 됨.

자세한건 10회차 관계에서 다룸.

링크 걸어둘 예정

### 6. 슈퍼 식별자 (Super Identifier)
---

후보 식별자에 +a 개념으로 속성이 추가 된 것

>**Warning**
>이미 유일성이 보장 된 속성 조합에 추가로 속성이 결합되었으므로 쓰지 말기를 권장함. \
>어떠한 경우에도 사용하지 않는 것을 원칙으로 해야함.

>**Note**
> (α) 슈퍼 식별자 예제

주문 엔티티

|order_id|customer_id|order_date|ship_date|status|
|---|---|---|---|---|
|1|1001|2023-01-01|2023-01-02|shipped|
|2|1002|2023-01-02|2023-01-03|shipped|
|3|1003|2023-01-03|2023-01-04|shipped|

여기서 `order_id`는 주 식별자로 사용됨. 

그러나 `customer_id`, `order_date`, `ship_date`, `status` 조합을 사용하여 주문을 고유하게 식별하는 슈퍼 식별자도 있음.

>**Note**
> (α) **커버링 인덱스**
> 커버링 인덱스는 쿼리에서 필요한 모든 데이터를 인덱스에서 직접 읽을 수 있도록 하는 인덱스. \
> 쿼리의 SELECT와 WHERE 절에 사용된 모든 칼럼이 인덱스에 포함되어 있으면 해당 인덱스를 커버링 인덱스라고 함. \
> 커버링 인덱스를 사용하면 테이블에 대한 추가적인 액세스 없이 인덱스에서 모든 필요한 데이터를 얻을 수 있어 쿼리의 성능을 크게 향상시킬 수 있음.

```sql
CREATE TABLE orders (
  order_id INT PRIMARY KEY,
  customer_id INT,
  order_date DATE,
  ship_date DATE,
  status VARCHAR(10)
);

CREATE INDEX idx_orders_covering
ON orders (customer_id, order_date, status);
```

이 경우에는 `idx_orders_covering` 인덱스가 커버링 인덱스로 사용될 수 있음

```sql
SELECT order_date, status
FROM orders
WHERE customer_id = 123 AND order_date BETWEEN '2023-01-01' AND '2023-12-31';
```


>**Note**
> (α) 슈퍼 식별자를 사용하면 안되는 주요 이유. \
> 책에서 해당 내용에 대한 설명이 없는 수준임 내용을 찾아서 보강해서 작성함.

####  커버링 인덱스를 사용하여 주 식별자에 속성을 추가하는 것은 잘못된 정책인 이유
---
1. **인덱스 크기 증가**
   주 식별자에 속성을 추가하면 인덱스 크기가 커져서 관리가 어렵고, 인덱스의 성능이 저하될 수 있음.
2. **데이터 중복성**
   슈퍼 식별자가 복잡해지면 데이터 중복성이 발생할 수 있으며, 이는 데이터 일관성을 유지하는 데 어려움을 초래함.
3. **쓰기 성능 저하**
   인덱스가 크면 쓰기 성능이 저하됨. \
   INSERT, UPDATE, DELETE 작업 시 인덱스를 유지해야 하므로 작업이 더 오래 걸림.

#### PK 인덱스는 오직 인스턴스를 생성하는 기준과 인스턴스를 식별하는 역할만 해야 함
---

PK 인덱스는 데이터를 고유하게 식별하고, 빠르게 조회할 수 있도록 하는 역할만 해야 함.

PK 인덱스에 다른 속성을 추가하면 인덱스의 복잡성이 증가하고, 인덱스 관리가 어려워짐.

#### 슈퍼 식별자가 정규형에 위배될 수도 있음.
---

슈퍼 식별자는 여러 속성의 조합이므로, 속성 중 하나라도 변경되면 식별자도 변경되어야 함.

이는 데이터의 일관성을 유지하는 데 어려움을 초래할 수 있음.

또한 슈퍼 식별자가 과도하게 복잡하면 데이터 모델의 복잡성이 증가하고, 엔터티의 성격이 불분명해질 수 있음.

#### 슈퍼 식별자가 엔터티의 성격을 불분명하게 함.
---

슈퍼 식별자는 여러 속성의 조합이므로, 엔터티의 식별이 다른 엔터티와의 관계를 통해 형성되는 경우, 엔터티의 성격이 불분명해지게 됨.

이는 데이터 모델의 복잡성을 증가시키며, 데이터 일관성을 유지하는데 어려움을 초래함.